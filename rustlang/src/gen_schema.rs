///
/// Generates type definitions for a specific airtable record type,
/// in a module... the structs are built to be deserializable.
///
#[macro_export]
macro_rules! gen_airtable_schema {

    (
        @gen $(
            $ns:ident, $ns_name:expr, $name:expr, $mapped_name:ident [ $(
                $json_name:expr, $field_name:ident, $field_type:ty, -> [ $($t:expr,)* ]: $t_field:ty
            )*], $({ $($tokens:tt)* })?
        )*
    ) => {

        use crate::airtable::{FetchCtx, *};
        use crate::compose;

        $(
            pub mod $ns {
                #![doc = "This namespace `"]
                #![doc = $ns_name]
                #![doc = "` is generated by [`gen_airtable_schema`](../../macro.gen_airtable_schema.html)."]
                #![allow(unused)]

                use serde::*;
                use serde_json::Value;
                use super::*;

                /// The table name of this airtable table.
                ///
                /// This will be used in `get_one`, and other functions
                /// defined in this namespace, to fetch data.
                pub const NAME: &'static str = $name;

                /// This is autogenerated, and corresponds to the `fields`
                /// internal to a single record.
                #[derive(Debug, Deserialize)]
                pub struct Fields {
                    $( #[serde(rename = $json_name)] pub $field_name: $field_type,)*
                }

                /// This is autogenerated, and corresponds to what the fully
                /// hydrated `One` transforms it into.
                #[derive(Debug, Serialize)]
                pub struct Mapped {
                    $( pub $field_name: $t_field, )*
                }

                /// A single record, see
                /// [`airtable::response::One`](../airtable/response/struct.One.html)
                pub type One = crate::airtable::response::One<Fields>;

                /// Many records, see
                /// [`airtable::response::Many`](../airtable/response/struct.Many.html)
                pub type Many = crate::airtable::response::Many<Fields>;

                // dump in arbitrary tokens, like any functions that were added to this module
                // after stuff has been defined.
                $($($tokens)*)?
            }

        #[allow(unused)]
        #[doc = "Generated alias from `"]
        #[doc = $ns_name]
        #[doc = ":: Mapped`."]
        pub type $mapped_name = $ns::Mapped;

        #[allow(unused)]
        impl $mapped_name {

            pub async fn fetch_many<T: AsRef<str>>(ctx: &mut FetchCtx, ids: Vec<T>) -> Result<Vec<$ns::One>, Error> {
                let mut fetched = Vec::with_capacity(ids.len());
                for id in ids {
                    fetched.push(Self::fetch_one(ctx, id).await?);
                }
                Ok(fetched)
            }

            /// Get a single typed record via the `FetchCtx`.
            pub async fn fetch_one<T: AsRef<str>>(ctx: &mut FetchCtx, id: T) -> Result<$ns::One, Error> {
                ctx.fetch_id($ns::NAME, id.as_ref()).await
            }

            /// Given a typed API response, create the fully hydrated `Mapped` resource.
            pub async fn create_one(ctx: &mut FetchCtx, one: $ns::One) -> Result<Self,  Error> {
                Ok(Self {
                    $($field_name: compose!(ctx, one.fields.$field_name, [ $($t,)* ])?),*
                })
            }

            /// Given a typed API response, creates _many_ hydrated `Mapped` resources.
            pub async fn create_many(ctx: &mut FetchCtx, many: Vec<$ns::One>) -> Result<Vec<Self>, Error> {
                let mut result = Vec::with_capacity(many.len());
                for one in many {
                    result.push(Self::create_one(ctx, one).await?);
                }
                Ok(result)
            }

            /// Query the API (not ID lookup), based on a QueryParam object.
            pub async fn query(ctx: &mut FetchCtx, p: request::QueryParam<'_, '_>) -> Result<$ns::Many, Error> {
                ctx.fetch_query($ns::NAME, &p.key, &p.value).await
            }

        }

        )*
    };

    (
        $(
            mod $ns:ident ($name: expr) as $mapped_name:ident {
                    $(
                        $k:expr => fn $fn:ident ($ft:ty) -> $t_ft:ty { $($tfs:expr),+ },
                    )*
            } $({ $($tokens:tt)* })?
        )*
    ) => {
        gen_airtable_schema! {
            @gen $(
                $ns, stringify!($ns), $name, $mapped_name [
                    $(
                        $k, $fn, $ft, -> [ $($tfs,)* ]: $t_ft
                     )*
                ],
                $({ $($tokens)* })?
            )*
        }
    }
}
