pub mod airtable {

    #[derive(Debug)]
    pub(crate) struct Config {
        pub key: String,
        pub base: String,
    }

    impl Config {
        pub(crate) fn from_env() -> Result<Self, &'static str> {
            use std::env;
            match (env::var("AIRTABLE_KEY"), env::var("AIRTABLE_APP")) {
                (Ok(key), Ok(base)) => Ok(Self { key, base }),
                _ => Err("Expected env variables AIRTABLE_KEY, and AIRTABLE_APP to be set"),
            }
        }
    }

    pub struct FetchCtx {
        config: Config,
        client: reqwest::Client,
    }

    impl FetchCtx {
        pub(crate) fn from_env() -> Result<Self, &'static str> {
            let config = Config::from_env()?;
            Ok(Self {
                config,
                client: reqwest::Client::new(),
            })
        }

        pub(crate) fn id_request(&self, table: &str, id: &str) -> reqwest::RequestBuilder {
            let url = format!(
                "https://api.airtable.com/v0/{base}/{table}/{id}",
                base = self.config.base,
                table = table,
                id = id
            );
            self.client.get(&url).bearer_auth(&self.config.key)
        }
    }

    pub mod response {

        use serde::Deserialize;

        #[derive(Deserialize, Debug)]
        pub struct One<T> {
            pub id: String,
            pub fields: T,
            #[serde(rename = "createdTime")]
            pub created_time: String,
        }

        #[derive(Deserialize, Debug)]
        pub struct Many<T> {
            pub records: Vec<One<T>>,
        }
    }
}

macro_rules! compose {
    ( $last:expr ) => { $last };
    ( $head:expr, $($tail:expr), +) => {
        compose_two($head, compose!($($tail),+))
    };
}

#[allow(unused)]
fn compose_two<A, B, C, G, F>(f: F, g: G) -> impl Fn(A) -> C
where
    F: Fn(A) -> B,
    G: Fn(B) -> C,
{
    move |x| g(f(x))
}

///
/// Generates type definitions for a specific airtable record type,
/// in a module... the structs are built to be deserializable
///
/// This will end up providing built in types and functions:
///
/// - `module::NAME` - the table name of the Airtable base
/// - `module::Fields` - a struct defining the fields of `NAME`
/// - `module::One` - a struct for a single record with `fields: Fields`
/// - `module::Many` - a struct for many `records` (for a mget), of `One`
/// - `module::get_one()` - a function to get `One` record
///
#[macro_export]
macro_rules! gen_airtable_types {
    (
        @gen $(
            $ns:ident, $ns_name:expr, $name:expr, [ $(
                $json_name:expr, $field_name:ident, $field_type:ty, -> [ $($t:expr,)* ]: $t_field:ty
            )*],
        )*
    ) => {
            $(
                #[doc = "This namespace `"]
                #[doc = $ns_name]
                #[doc = "` is generated by [`gen_airtable_types`](../macro.gen_airtable_types.html)."]
                pub mod $ns {
                    #![allow(unused)]

                    use serde::*;
                    use serde_json::Value;
                    use crate::airtable::FetchCtx;
                    use super::*;

                    /// The table name of this airtable table.
                    ///
                    /// This will be used in `get_one`, and other functions
                    /// defined in this namespace, to fetch data.
                    pub const NAME: &'static str = $name;

                    /// This is autogenerated, and corresponds to the `fields`
                    /// internal to a single record.
                    #[derive(Debug, Deserialize)]
                    pub struct Fields {
                        $( #[serde(rename = $json_name)] pub $field_name: $field_type,)*
                    }

                    /// This is autogenerated, and corresponds to what the fully
                    /// hydrated `One` transforms it into.
                    ///
                    /// See: [`map`](./fn.map.html)
                    #[derive(Debug)]
                    pub struct Mapped<'a> {
                        $( pub $field_name: $t_field, )*
                    }

                    pub type One = crate::airtable::response::One<Fields>;

                    pub type Many = crate::airtable::response::Many<Fields>;

                    /// Get a single typed record via the `FetchCtx`.
                    pub async fn get_one(ctx: &FetchCtx, id: &str) -> Result<One, reqwest::Error> {
                        ctx.id_request(NAME, id).send().await?.json::<One>().await
                    }

                    /// Get a signle _dynamic_ JSON record via the `FetchCtx`.
                    pub async fn get_one_dynamic(ctx: &FetchCtx, id: &str) -> Result<Value, reqwest::Error> {
                        ctx.id_request(NAME, id).send().await?.json::<Value>().await
                    }

                    /// Given a typed API response, create the fully hydrated `Mapped` resource.
                    pub async fn map<'a>(one: &'a One) -> Mapped<'a> {
                        Mapped {
                            $($field_name: {
                                let f = compose!($($t),*);
                                f(&one.fields.$field_name)
                            }),*
                        }
                    }

                }
            )*
    };

    (
        $(
            $ns:ident
                - from: $name: expr,
                - fields: [
                    $(
                        $json_key:expr => {
                            $field_name:ident ($field_type:ty) -> $($transform:ident),+ : $t_field_type:ty
                        },
                    )*
                ]
        ),*
    ) => {
        gen_airtable_types! {
            @gen $(
                $ns, stringify!($ns), $name, [
                    $(
                        $json_key, $field_name, $field_type,
                        -> [ $($transform,)* ]: $t_field_type
                     )*
                ],
            )*
        }
    }
}

pub fn copy<T: Copy>(t: &T) -> T {
    *t
}

pub fn id<T: ?Sized>(t: &T) -> &T {
    t
}

pub fn first<'a, T>(list: &'a Vec<T>) -> &'a T {
    list.first().unwrap()
}

pub fn force_bool(val: &Option<bool>) -> bool {
    val.unwrap_or(false)
}

type MaybeBool = Option<bool>;
type IDs = Vec<String>;

gen_airtable_types! {
    invoice_item
        - from: "Invoice Item",
        - fields: [
            "Date" => { date(String) -> id: &'a str },
            "Description" => { description(String) -> id: &'a str },
            "Quantity" => { quantity(u32) -> copy: u32 },
            "Amount" => { amount(u32) -> copy: u32 },
        ]
}

gen_airtable_types! {
    invoice_client
        - from: "Clients",
        - fields: [
            "Company" => { company(String) -> id: &'a str },
            "ContactEmail" => { contact_email(String) -> id: &'a str },
            "ContactName" => { contact_name(String) -> id: &'a str },
            "Website" => { website_url(String) -> id: &'a str },
        ]
}

gen_airtable_types! {
    invoice
        - from: "Invoice",
        - fields: [
            "ID" => { id(u32) -> copy: u32 },
            "Invoice Number" => { number(String) -> id: &'a str },
            "Notes" => { notes(Option<String>)  -> id: &'a Option<String> },
            "Due Date" => { due_date(String) -> id: &'a str },
            "Date" => { date(String) -> id: &'a str },
            "Paid" => { paid(MaybeBool) -> force_bool: bool },
            "Sent" => { sent(MaybeBool) -> force_bool: bool },
            "Client" => { client(IDs) -> first: &'a String },
            "Invoice Item" => { items(IDs) -> id: &'a IDs },
        ]
}

#[tokio::main]
async fn main() -> Result<(), reqwest::Error> {
    //
    // We need to have the config in order to be able to talk
    // to the Airtable API at all.
    let ctx = airtable::FetchCtx::from_env().unwrap();
    let an_invoice = dbg!(invoice::get_one(&ctx, "recLYHi5nzYLlHseu").await?);

    /*
    let invoice_item_id = dbg!(an_invoice.fields.invoice_items.first().unwrap());
    let client_id = dbg!(an_invoice.fields.client.first().unwrap());

    dbg!(invoice_item::get_one(&ctx, invoice_item_id).await?);
    dbg!(invoice_client::get_one(&ctx, client_id).await?);
    */

    dbg!(invoice::map(&an_invoice).await);

    Ok(())
}
